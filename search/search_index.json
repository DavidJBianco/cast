{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cast \u00b6 Cast is an installer tool for any Cast distro like SIFT or REMNUX . Usage \u00b6 cast install <owner/repo | alias> Note: there are only two aliases currently supported, sift and remnux which are resolved to teamdfir/sift-saltstack and remnux/salt-states respectively. What is a Cast Distro? \u00b6 Simply put a cast distro is one published by the cast binary, however it's a bit more complicated than that. The underlying technology used for installing the distro is Saltstack. There are only two (2) version 1 cast distros out there and they are SIFT and REMnux and what makes them a v1 is the way the release files are generated and signed and how the saltstack files are organized in the repository. A version 2 cast distro is one like example-distro-saltstack where the salt states start in the root of the project and the release is generated by the cast-devtools . The reason for moving the states to the root is for git submodule usage for distros that extend another distro. Configuration \u00b6 Cast is configured via the .cast.yml file in the root of the cast distro project. This configuration is required and contains important information like what GitHub Repository should releases be published to, what the manifest file contents should be. Part of the configuration is the manifest definition that ultimately gets uploaded as a release asset. The manifest dictates things like base , modes , and supported operating systems . base - this is the name of the base directory that the files should be extracted into modes - this is a way to define modes that the user can specify along with the default mode, if none is specified supported_os - this is a way to define what operating systems are supported For Developers \u00b6 If your distro is called alpha then your base should be alpha , all salt states will be homed into a directory called alpha Aliases \u00b6 Cast has the concept of aliases and it's possible to add additional distros to this alias list. However the aliases serve a more specific purpose for supporing backwards compatibility for older versions of SIFT and REMnux that were not released as a cast distro originally. Developers \u00b6 Developing a distro for cast is very simple, this documentation will walk you through cast initialization. Saltstack \u00b6 To make embedding a distro easier in another distro both for the community and for SANS builds purposes, the salt states have now been moved to the root of the project. This allows for a repo to be submoduled into another repo and the manifest.yml dictates to the installer how things should be extracted and installed. Futhermore the devtools contains commands to help developers test their states in the correct structure format. Release \u00b6 Requirements Tag must be created outside of the tool and pushed to the remote Cosign private key and public key must be present in the repo Creating a release has never been more simply. However one thing is required, that you tag and push the tag to GitHub prior to running the command. git tag v1.0.0 && git push origin --tags Then you simply run the release command from your local branch. cast-devtools release","title":"Home"},{"location":"#cast","text":"Cast is an installer tool for any Cast distro like SIFT or REMNUX .","title":"Cast"},{"location":"#usage","text":"cast install <owner/repo | alias> Note: there are only two aliases currently supported, sift and remnux which are resolved to teamdfir/sift-saltstack and remnux/salt-states respectively.","title":"Usage"},{"location":"#what-is-a-cast-distro","text":"Simply put a cast distro is one published by the cast binary, however it's a bit more complicated than that. The underlying technology used for installing the distro is Saltstack. There are only two (2) version 1 cast distros out there and they are SIFT and REMnux and what makes them a v1 is the way the release files are generated and signed and how the saltstack files are organized in the repository. A version 2 cast distro is one like example-distro-saltstack where the salt states start in the root of the project and the release is generated by the cast-devtools . The reason for moving the states to the root is for git submodule usage for distros that extend another distro.","title":"What is a Cast Distro?"},{"location":"#configuration","text":"Cast is configured via the .cast.yml file in the root of the cast distro project. This configuration is required and contains important information like what GitHub Repository should releases be published to, what the manifest file contents should be. Part of the configuration is the manifest definition that ultimately gets uploaded as a release asset. The manifest dictates things like base , modes , and supported operating systems . base - this is the name of the base directory that the files should be extracted into modes - this is a way to define modes that the user can specify along with the default mode, if none is specified supported_os - this is a way to define what operating systems are supported","title":"Configuration"},{"location":"#for-developers","text":"If your distro is called alpha then your base should be alpha , all salt states will be homed into a directory called alpha","title":"For Developers"},{"location":"#aliases","text":"Cast has the concept of aliases and it's possible to add additional distros to this alias list. However the aliases serve a more specific purpose for supporing backwards compatibility for older versions of SIFT and REMnux that were not released as a cast distro originally.","title":"Aliases"},{"location":"#developers","text":"Developing a distro for cast is very simple, this documentation will walk you through cast initialization.","title":"Developers"},{"location":"#saltstack","text":"To make embedding a distro easier in another distro both for the community and for SANS builds purposes, the salt states have now been moved to the root of the project. This allows for a repo to be submoduled into another repo and the manifest.yml dictates to the installer how things should be extracted and installed. Futhermore the devtools contains commands to help developers test their states in the correct structure format.","title":"Saltstack"},{"location":"#release","text":"Requirements Tag must be created outside of the tool and pushed to the remote Cosign private key and public key must be present in the repo Creating a release has never been more simply. However one thing is required, that you tag and push the tag to GitHub prior to running the command. git tag v1.0.0 && git push origin --tags Then you simply run the release command from your local branch. cast-devtools release","title":"Release"},{"location":"distro/","text":"Distro \u00b6 A Cast Distro is simply a self contained set of Saltstack states that get bundled up by the Cast binary such that they are signed and downloadable by the tool to be installed against a linux system. If you are familiar with Saltstack this should be a fairly straightfoward process, if you are however unfamiliar with Saltstack some additional learning will be required to get up to speed, to help with that there's a saltstack primer located in this documentation. Organization \u00b6 The most important aspect of a Cast distro is how the salt states are organized. Typically speaking you'd have a directly, let's call it example and within it you'd define a state file server.sls and this file would do something like pkg.install of htop . However to allow Cast distributions to be required by other Cast distributions, we leave the creation of the folder example up to Cast, instead a manifest is defined to set the name of the project (aka base) of where all the files starting at the root of the repository will be extracted to. The primary purpose for this is to allow another distro to use git submodules to essentially include distro A into distro B. Manifest \u00b6 The manifest is a file that is included with the releases assets on a GitHub Release that provides context to the installer for the distro. Specification \u00b6 Note: base_dir is if the base of the salt states are in a directory other than the root of the project. name : sift base_dir : sift modes : - name : desktop state : sift.desktop - name : server state : sift.server default : true - name : packages-only state : sift.server deprecated : true replacement : server - name : complete state : sift.desktop deprecated : true replacement : desktop supported_os : - id : ubuntu release : 20.04 focal : focal saltstack : pillars : distro_user_template : '{{ .User }}' Modes \u00b6 Modes are essentially aliases and born from the original install tools from SIFT and REMnux. These modes allow for defining a single name alias like desktop to point to sift.desktop Supported Operating Systems (OS) \u00b6 SupportedOS allows for defining what operating systems are officially supported by the distro. supported_os : - id : ubuntu release : 20.04 focal : focal SaltStack \u00b6 The saltstack sections allows for configuring aspects of SaltStack. At this time it only allows for passing custom pillar data. Pillars \u00b6 Pillars are essentially data that's made available to the SaltStack run, currently it only supports a key: value format, it does not support nested data. Important The _template suffix has special meaning. It indicates a template variable, the value before the _template is the actual end result variable name. (eg sift_user_template becomes sift_user ) saltstack : pillars : sift_user_template : \"{{ .User }}\" Template Data \u00b6 This is the data available to the template process. user : SUDO_SUER user, this is the CLI option --user but defaults to SUDO_USER environment variable, as the tool is only suppose to be run with sudo.","title":"Distro"},{"location":"distro/#distro","text":"A Cast Distro is simply a self contained set of Saltstack states that get bundled up by the Cast binary such that they are signed and downloadable by the tool to be installed against a linux system. If you are familiar with Saltstack this should be a fairly straightfoward process, if you are however unfamiliar with Saltstack some additional learning will be required to get up to speed, to help with that there's a saltstack primer located in this documentation.","title":"Distro"},{"location":"distro/#organization","text":"The most important aspect of a Cast distro is how the salt states are organized. Typically speaking you'd have a directly, let's call it example and within it you'd define a state file server.sls and this file would do something like pkg.install of htop . However to allow Cast distributions to be required by other Cast distributions, we leave the creation of the folder example up to Cast, instead a manifest is defined to set the name of the project (aka base) of where all the files starting at the root of the repository will be extracted to. The primary purpose for this is to allow another distro to use git submodules to essentially include distro A into distro B.","title":"Organization"},{"location":"distro/#manifest","text":"The manifest is a file that is included with the releases assets on a GitHub Release that provides context to the installer for the distro.","title":"Manifest"},{"location":"distro/#specification","text":"Note: base_dir is if the base of the salt states are in a directory other than the root of the project. name : sift base_dir : sift modes : - name : desktop state : sift.desktop - name : server state : sift.server default : true - name : packages-only state : sift.server deprecated : true replacement : server - name : complete state : sift.desktop deprecated : true replacement : desktop supported_os : - id : ubuntu release : 20.04 focal : focal saltstack : pillars : distro_user_template : '{{ .User }}'","title":"Specification"},{"location":"distro/#modes","text":"Modes are essentially aliases and born from the original install tools from SIFT and REMnux. These modes allow for defining a single name alias like desktop to point to sift.desktop","title":"Modes"},{"location":"distro/#supported-operating-systems-os","text":"SupportedOS allows for defining what operating systems are officially supported by the distro. supported_os : - id : ubuntu release : 20.04 focal : focal","title":"Supported Operating Systems (OS)"},{"location":"distro/#saltstack","text":"The saltstack sections allows for configuring aspects of SaltStack. At this time it only allows for passing custom pillar data.","title":"SaltStack"},{"location":"distro/#pillars","text":"Pillars are essentially data that's made available to the SaltStack run, currently it only supports a key: value format, it does not support nested data. Important The _template suffix has special meaning. It indicates a template variable, the value before the _template is the actual end result variable name. (eg sift_user_template becomes sift_user ) saltstack : pillars : sift_user_template : \"{{ .User }}\"","title":"Pillars"},{"location":"distro/#template-data","text":"This is the data available to the template process. user : SUDO_SUER user, this is the CLI option --user but defaults to SUDO_USER environment variable, as the tool is only suppose to be run with sudo.","title":"Template Data"},{"location":"migrate/","text":"Migrating to Cast \u00b6 This is a migration guide for existing distros that are using some variation of the sift-cli like SIFT or REMnux. Overview \u00b6 Cast is a singlular tool designed to install, test and release cast compatible distributions that are built with SaltStack. It uses a single file in the project root called .cast.yml to define how releases and installations take place. Cast uses cosign to sign all releases but supports the legacy PGP signing that the sift-cli and remnux-cli uses. Design \u00b6 A Cast distro is a bunch of SaltStack states and there's and how they are organized is very flexible but there is a recommended base organization. To support embedding states from one project into another project using git submodules, it is recommended that all base states start in the root of the project. A base state is generally a target for building like desktop or server or dedicated or standalone . All other states are encourage to be in subdirectories that make sense from a human readability and organization standpoint. This design allows for a distro to be submoduled into another distro. Development \u00b6 During development of a Cast distro, Cast provides testing tools but if you'd like to use SaltStack directly you simply need to honor a few guidelines for how to setup your development environment. For example if you are building a distro called example you'd want your file root for saltstack to be /tmp/salt with your Cast distro cloned into /tmp/salt/example . Migrating \u00b6 To migrate to Cast and to use Cast to manage all your releases there are a few steps that must be taken. Create a Cosign Private and Public Key Ensure you have your PGP Private and Public Key Create a .cast.yml file and populate it properly. Modify .gitignore Commit changes Create a tag Create a release Migration by Example \u00b6 The current version of SIFT is not in the recommended format. All base states exist in a subfolder within the root of the project, but Cast is designed to handle this scenario if it's required. To migrate SIFT as it is currently, the Cast file would look like the following. version : 2 name : sift base_dir : sift modes : - name : server state : sift.server default : true supported_os : - name : ubuntu Since all the states exist within the sift folder we define the base_dir as sift, this is how we ensure files get packed and unpacked properly for execution. The modes are a carry over from the sift-cli and the easy modes that make represent an installation mode for the distro, modes allows for a default to be specified and what the modes are and what state should be called as a result, this allows for a great deal of flexibility by a distro author. Finally the supported OS provides a way to indicate if the target OS is supported or not. Once the .cast.yml is in place and committed to the repository, we can create our first tag and publish using Cast. Since we want to maintain backwards compatibility with the sift-cli we'll enable legacy signing using PGP. First, update your .gitignore and ignore *.key Second, create your cosign keys. cosign generate-keypair Third, copy your PGP keys as pgp.key and pgp.pub . Fourth, create a new tag and push it to the remote. Finally, run Cast to release. cast release --legacy-pgp-sign This will do some basic validation and package the distro for release and upload all the assets to GitHub Releases. Congrats!","title":"Migration"},{"location":"migrate/#migrating-to-cast","text":"This is a migration guide for existing distros that are using some variation of the sift-cli like SIFT or REMnux.","title":"Migrating to Cast"},{"location":"migrate/#overview","text":"Cast is a singlular tool designed to install, test and release cast compatible distributions that are built with SaltStack. It uses a single file in the project root called .cast.yml to define how releases and installations take place. Cast uses cosign to sign all releases but supports the legacy PGP signing that the sift-cli and remnux-cli uses.","title":"Overview"},{"location":"migrate/#design","text":"A Cast distro is a bunch of SaltStack states and there's and how they are organized is very flexible but there is a recommended base organization. To support embedding states from one project into another project using git submodules, it is recommended that all base states start in the root of the project. A base state is generally a target for building like desktop or server or dedicated or standalone . All other states are encourage to be in subdirectories that make sense from a human readability and organization standpoint. This design allows for a distro to be submoduled into another distro.","title":"Design"},{"location":"migrate/#development","text":"During development of a Cast distro, Cast provides testing tools but if you'd like to use SaltStack directly you simply need to honor a few guidelines for how to setup your development environment. For example if you are building a distro called example you'd want your file root for saltstack to be /tmp/salt with your Cast distro cloned into /tmp/salt/example .","title":"Development"},{"location":"migrate/#migrating","text":"To migrate to Cast and to use Cast to manage all your releases there are a few steps that must be taken. Create a Cosign Private and Public Key Ensure you have your PGP Private and Public Key Create a .cast.yml file and populate it properly. Modify .gitignore Commit changes Create a tag Create a release","title":"Migrating"},{"location":"migrate/#migration-by-example","text":"The current version of SIFT is not in the recommended format. All base states exist in a subfolder within the root of the project, but Cast is designed to handle this scenario if it's required. To migrate SIFT as it is currently, the Cast file would look like the following. version : 2 name : sift base_dir : sift modes : - name : server state : sift.server default : true supported_os : - name : ubuntu Since all the states exist within the sift folder we define the base_dir as sift, this is how we ensure files get packed and unpacked properly for execution. The modes are a carry over from the sift-cli and the easy modes that make represent an installation mode for the distro, modes allows for a default to be specified and what the modes are and what state should be called as a result, this allows for a great deal of flexibility by a distro author. Finally the supported OS provides a way to indicate if the target OS is supported or not. Once the .cast.yml is in place and committed to the repository, we can create our first tag and publish using Cast. Since we want to maintain backwards compatibility with the sift-cli we'll enable legacy signing using PGP. First, update your .gitignore and ignore *.key Second, create your cosign keys. cosign generate-keypair Third, copy your PGP keys as pgp.key and pgp.pub . Fourth, create a new tag and push it to the remote. Finally, run Cast to release. cast release --legacy-pgp-sign This will do some basic validation and package the distro for release and upload all the assets to GitHub Releases. Congrats!","title":"Migration by Example"}]}